- [0. BEGIN](#0)
	- [0.1 Things to do first](#0.1)

- [1. GET STARTED](#1)
	- [1.1 Let's get hacking!](#1.1)
		- [1.1.1 General-purpose programming in Python](#1.1.1)
	
	- [1.2 Do the math... (no shortcuts!)](#1.2)
		- [1.2.1 Linear algebra](#1.2.1)
		- [1.2.2 Calculus](#1.2.2)
		- [1.2.3 Multivariable calculus](#1.2.3)
		- [1.2.4 Discrete mathematics (graphs and stuff)](#1.2.4)
		- [1.2.5 Statistics and probability](#1.2.5)
	
	- [1.3 Moar programming skills (because basics)](#1.3)
		- [1.3.1 Object-oriented programming in Java](#1.3.1)
		- [1.3.2 Lower-level programming in C](#1.3.2)
	
	- [1.4 The science in computer science](#1.4)
		- [1.4.1 Computation and complexity](#1.4.1)
		- [1.4.2 Algorithms](#1.4.2)
	
	- [1.5 Engineering basics](#1.5)
		- [1.5.1 Classical mechanics](#1.5.1)
		- [1.5.2 Electronics and circuit theory](#1.5.2)
		- [1.5.3 Electromagnetism](#1.5.3)
	
	- [1.6 Computer systems](#1.6)
		- [1.6.1 Logic and digital systems](#1.6.1)
		- [1.6.2 Computer organisation and architecture](#1.6.2)
		- [1.6.3 Operating systems](#1.6.3)
		- [1.6.4 Databases](#1.6.4)

	- [1.X Ready to build?](#1.X)

- [2. GET GOOD](#2)
	- [2.1 Moar programming skills (and stranger?)](#2.1)
		- [2.1.1 Functional programming in Standard ML, Common Lisp, Ruby](#2.1.1)

	- [2.2 Do more math...](#2.2)
		- [2.2.1 Differential equations (ODE and PDE)](#2.2.1)
		- [2.2.2 Number theory](#2.2.2)
		
	- [2.3 The really useful science in computer science](#2.3)
		- [2.3.1 Computational models](#2.3.1)
		- [2.3.2 Compilers and formal language](#2.3.2)

	- [2.4 Some more engineering stuff (because smart)](#2.4)
		- [2.4.1 Signals and systems](#2.4.1)

	- [2.5 Applications](#2.5)
		- [2.5.1 Machine learning](#2.5.1)
		- [2.5.2 Robotics](#2.5.2)
		- [2.5.3 Cryptography](#2.5.3)

	- [2.X So... what now?](#2.X)

- [3. GET GREAT](#3)
	- [3.1 Even moar programming sills (because unlimited power!)](#3.1)
		- [3.1.1 Logic programming in Prolog](#3.1.1)
		- [3.1.2 Performance programming in C++](#3.1.2)
		- [3.1.3 Parallel programming in Scala](#3.1.3)
		- [3.1.4 Pure functional programming in Haskell](#3.1.4)
	
	- [3.2 Do even more math... (but not more than that!)](#3.2)
		- [3.2.1 Deterministic and stochastic dynamics](#3.2.1)
		- [3.3.2 Graph theory](#3.2.2)

	- [3.3 Advanced computer science (you better didn't skip the math!)](#3.3)
		- [3.3.1 Optimisation and evolutionary algorithms](#3.3.1)
		- [3.3.2 Computational intelligence](#3.3.2)

	- [3.4 Computer systems](#3.4)
		- [3.4.1 Computer security](#3.4.1)

	- [3.5 Applications](#3.5)
		- [3.5.1 Intelligent agents (AI)](#3.5.1)
		- [3.5.2 Neural networks and deep learning](#3.5.2)
		- [3.5.3 Computer vision](#3.5.3)

- [4. END](#4)
	- [4.1 Things to do now (or not, your choice!)](#4.1)
		- [4.1.1 Space science and engineering](#4.1.1)
		- [4.1.2 Quantum computing](#4.1.2)
		- [4.1.3 Artifical general intelligence](#4.1.3)